<!doctype html>
<html environmentJSON="{{ environmentJSON }}">
  <head>
    <meta charset="utf-8" />
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ googleAnalyticsId }}"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){ dataLayer.push(arguments); }
      gtag("js", new Date());
      gtag("config", "{{ googleAnalyticsId }}");
      gtag("consent","default",{ad_storage:"denied",ad_user_data:"denied",ad_personalization:"denied",analytics_storage:"denied"});
    </script>

    <link rel="stylesheet" type="text/css" href="/css/improved-initiative.{{ appVersion }}.css" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <meta http-equiv="content-language" content="en-us" />
    <title>Combat Tracker - Improved Initiative</title>

    <script type="text/javascript" src="/js/ImprovedInitiative.{{ appVersion }}.js"></script>

    <style>
      /* loading */
      .loading-splash{position:fixed;width:100%;height:100%;z-index:10;display:flex;flex-flow:column;align-items:center;justify-content:center;font-weight:bold;background:rgba(1,1,1,.7)}
      .loading-splash img{animation:bob 1s ease infinite}
      @keyframes bob{0%{margin-top:0}50%{margin-top:20px}}

:root{
        --dock-btn-width: 150px;
        --dock-btn-height: 58px;
        --dock-btn-radius: 14px;
        --dock-btn-font: 17px;
        --dock-gap: 10px;
        --dock-pad: 12px;
        --dock-border: 14px;
      }

      /* GM Dock container */
      #gmDock{
        position:fixed; right:12px; bottom:12px; z-index:9999;
        display:flex; flex-direction:column; gap:var(--dock-gap);
        background:rgba(14,27,42,.9);
        border:1px solid rgba(161,90,47,.35);
        border-radius:var(--dock-border); padding:var(--dock-pad);
        backdrop-filter:blur(4px);
        box-shadow:0 12px 28px rgba(14,27,42,.28);
        touch-action:manipulation; user-select:none; cursor:default;
      }
      #gmDock.left{ right:auto; left:12px; }
      #gmDock.dragging{ cursor:grabbing; }
      #gmDock.compact{
        --dock-btn-width: 132px;
        --dock-btn-height: 46px;
        --dock-btn-radius: 12px;
        --dock-btn-font: 15px;
        --dock-gap: 8px;
        --dock-pad: 10px;
        --dock-border: 12px;
      }
      #gmDock .drag-handle{
        height:12px; margin-bottom:4px; display:flex; align-items:center; justify-content:center;
        cursor:grab; touch-action:none;
      }
      #gmDock .drag-handle::after{
        content:""; width:46px; height:4px; border-radius:999px; background:rgba(255,255,255,.25); box-shadow:0 1px 0 rgba(0,0,0,.25);
      }
      #gmDock.dragging .drag-handle{ cursor:grabbing; }
      #gmDock .section{
        background:rgba(22,36,52,.92);
        border-radius:12px;
        border:1px solid rgba(161,90,47,.2);
        overflow:hidden;
      }
      #gmDock .section + .section{ margin-top:var(--dock-gap); }
      #gmDock .section-toggle{
        width:100%; border:0; background:rgba(161,90,47,.16);
        color:#f4ede6; font-weight:700; font-size:14px; padding:9px 10px;
        display:flex; align-items:center; justify-content:space-between; cursor:pointer;
        text-transform:uppercase; letter-spacing:0.5px;
      }
      #gmDock .section-toggle .chevron{
        width:0; height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-top:7px solid rgba(244,237,230,.82);
        transition:transform .15s ease;
      }
      #gmDock .section.collapsed .section-toggle .chevron{ transform:rotate(-90deg); }
      #gmDock .section-body{ padding:10px; display:flex; flex-direction:column; gap:8px; transition:max-height .18s ease, opacity .15s ease; }
      #gmDock .section.collapsed .section-body{ max-height:0; opacity:0; padding-top:0; padding-bottom:0; pointer-events:none; }
      #gmDock .row{ display:flex; gap:10px; align-items:center; justify-content:center; }
      #gmDock .row.dual{ display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
      #gmDock.compact .row.dual{ gap:8px; }
      #gmDock .btn{
        min-width:var(--dock-btn-width); width:100%;
        height:var(--dock-btn-height); border-radius:var(--dock-btn-radius);
        border:1px solid rgba(161,90,47,.55);
        background:linear-gradient(180deg,#a15a2f,#8f4e29);
        color:#f4ede6; font-weight:700; font-size:var(--dock-btn-font); cursor:pointer;
        transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
        padding:10px 12px;
      }
      #gmDock .btn:disabled{
        opacity:.55; cursor:not-allowed; filter:saturate(.6);
      }
      #gmDock .btn:hover{ transform:translateY(-1px); box-shadow:0 0 0 2px rgba(161,90,47,.35); filter:brightness(1.02); }
      #gmDock .btn:focus{ outline:2px solid #a15a2f; outline-offset:2px; }
      #gmDock .btn.secondary{
        background:rgba(25,52,79,.9);
        color:#f4ede6;
        border-color:rgba(161,90,47,.35);
      }
      #gmDock .btn.danger{
        background:linear-gradient(180deg,#b23535,#9a2e2e);
        border-color:rgba(178,53,53,.6);
      }
      #gmDock .btn.success{
        background:linear-gradient(180deg,#2f9e69,#287d58);
        border-color:rgba(161,90,47,.45);
      }
      #gmDock .btn.primary{
        background:linear-gradient(180deg,#a15a2f,#8f4e29);
        min-width:var(--dock-btn-width); color:#f4ede6;
      }
      #gmDock .btn.small{
        min-width:var(--dock-btn-width); height:48px; font-size:15px; padding:8px 12px;
      }
      #gmDock .btn.micro{
        min-width:var(--dock-btn-width); height:42px; font-size:14px; padding:6px 10px;
      }
      #gmDock.compact .btn{ height:calc(var(--dock-btn-height) - 8px); font-size:calc(var(--dock-btn-font) - 1px); border-radius:10px; padding:8px 10px; }
      #gmDock.compact .btn.micro{ height:36px; font-size:13px; }
      #gmDock .btn[data-badge]:after{
        content:attr(data-badge);
        display:inline-flex; align-items:center; justify-content:center;
        margin-left:8px; min-width:18px; height:18px; border-radius:9px;
        background:rgba(0,0,0,.25); padding:0 6px; font-size:12px; font-weight:700;
      }
      #gmDock .btn[data-badge=""]::after{ display:none; }

      @keyframes gmPulse { 0%{transform:scale(1)} 50%{transform:scale(.96)} 100%{transform:scale(1)} }
      #gmDock .btn.pulse { animation: gmPulse .18s ease; }

      /* numpad */
      #numPad{position:fixed;inset:0;z-index:10000;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
      #numPad .pad{width:min(92vw,420px);background:#111;color:#fff;border-radius:16px;border:1px solid rgba(255,255,255,.18);padding:14px;box-shadow:0 20px 40px rgba(0,0,0,.5)}
      #numPad .title{font:700 16px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;opacity:.95;margin-bottom:8px}
      #numPad .display{height:52px;display:flex;align-items:center;justify-content:flex-end;border:1px solid rgba(255,255,255,.2);border-radius:10px;padding:0 12px;font-size:26px;background:#000;margin-bottom:10px;letter-spacing:1px}
      #numPad .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
      #numPad .key{height:56px;border-radius:12px;border:1px solid rgba(255,255,255,.2);background:#222;color:#fff;font:700 20px/1 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;cursor:pointer}
      #numPad .key.wide{grid-column:span 2}
      #numPad .key.danger{background:#c11}
      #numPad .key.success{background:#0a5}
      #numPad .targets{margin:8px 0 4px 0; background:#0a0a0a; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:8px; max-height:none; overflow:visible;}
      #numPad .target-row{display:grid; grid-template-columns:1fr 96px; gap:8px; align-items:center; padding:6px 0; border-bottom:1px solid rgba(255,255,255,.08);}
      #numPad .target-row:last-child{border-bottom:0;}
      #numPad .target-name{color:#f4f4f4; font:600 14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
      #numPad .target-mod{width:100%; height:36px; border-radius:9px; border:1px solid rgba(255,255,255,.2); background:#111; color:#fff; font:600 13px ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; padding:6px 8px; }
      #numPad .targets.empty{display:none;}

      /* toast feedback */
      #gmToast{
        position:fixed; right:14px; bottom:86px; z-index:10001;
        min-width:140px; max-width:60vw; padding:10px 14px;
        border-radius:12px; color:#fff; font:700 14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
        background:rgba(30,30,30,.95); border:1px solid rgba(255,255,255,.15);
        box-shadow:0 10px 30px rgba(0,0,0,.35); opacity:0; transform:translateY(8px);
        pointer-events:none; transition:opacity .18s ease, transform .18s ease;
      }
      #gmToast.show{ opacity:1; transform:translateY(0); }
      #gmToast.dmg{ background:linear-gradient(180deg,#c11,#a10); }
      #gmToast.heal{ background:linear-gradient(180deg,#15803d,#0f6d33); }

      /* small responsive tweak */
      @media(max-width:520px){
        #gmDock .btn{ min-width:84px; height:48px; font-size:16px; }
        #gmDock{ right:8px; bottom:8px; padding:8px; border-radius:12px; }
      }
    </style>
	<script defer src="/hudStream.js"></script>
  </head>

  <body id="tracker">
    <div class="loading-splash">
      <img src="../img/boot-white-on-darkred-192.png" alt="Improved Initiative Flying Boot Logo" />
      <p>Loading Improved Initiative</p>
    </div>

    <div id="app__container"></div>

        <!-- GM Dock -->
    <div id="gmDock" role="toolbar" aria-label="GM Touch Dock">
      <div class="drag-handle" id="dockHandle" aria-hidden="true"></div>
      <div class="section" data-section="active">
        <button class="section-toggle" data-section-toggle="active">
          <span>Active target</span><span class="chevron"></span>
        </button>
        <div class="section-body">
          <div class="row">
            <button class="btn danger"  id="btnDmg" aria-label="Damage active target">DMG</button>
            <button class="btn success" id="btnHeal" aria-label="Heal active target">HEAL</button>
          </div>
          <div class="row dual">
            <button class="btn primary small" id="btnPrev" aria-label="Go to previous turn"><< Back</button>
            <button class="btn primary small" id="btnNext" aria-label="Go to next turn">Next >></button>
          </div>
        </div>
      </div>

      <div class="section" data-section="selection">
        <button class="section-toggle" data-section-toggle="selection">
          <span>Sélection</span><span class="chevron"></span>
        </button>
        <div class="section-body">
          <div class="row dual">
            <button class="btn secondary small" id="btnSelectAll" aria-label="Select all combatants">Select all</button>
            <button class="btn secondary small" id="btnClearSel" aria-label="Clear selection">Clear</button>
          </div>
          <div class="row dual">
            <button class="btn danger small" id="btnGroupDmg" aria-label="Damage selected combatants">Group DMG</button>
            <button class="btn success small" id="btnGroupHeal" aria-label="Heal selected combatants">Group HEAL</button>
          </div>
        </div>
      </div>

      <div class="section" data-section="players">
        <button class="section-toggle" data-section-toggle="players">
          <span>Joueurs</span><span class="chevron"></span>
        </button>
        <div class="section-body">
          <div class="row dual">
            <button class="btn danger small" id="btnPlayersDmg" aria-label="Damage all player characters">Players DMG</button>
            <button class="btn success small" id="btnPlayersHeal" aria-label="Heal all player characters">Players HEAL</button>
          </div>
        </div>
      </div>

      <div class="section" data-section="layout">
        <button class="section-toggle" data-section-toggle="layout">
          <span>Dock</span><span class="chevron"></span>
        </button>
        <div class="section-body">
          <div class="row dual">
            <button class="btn secondary micro" id="btnFlip" aria-label="Move dock left or right" title="Move dock left / right">Flip side</button>
            <button class="btn secondary micro" id="btnCompact" aria-label="Toggle compact mode" title="Toggle compact mode">Mode compact</button>
          </div>
        </div>
      </div>
    </div>
<!-- pavé numérique -->
    <div id="numPad" aria-hidden="true">
      <div class="pad" role="dialog" aria-modal="true" aria-label="Numeric pad">
        <div class="title" id="padTitle">Enter amount</div>
        <div class="display" id="padDisplay">0</div>
        <div class="targets empty" id="padTargets">
          <div class="target-list"></div>
        </div>
        <div class="grid">
          <button class="key">1</button><button class="key">2</button><button class="key">3</button>
          <button class="key">4</button><button class="key">5</button><button class="key">6</button>
          <button class="key">7</button><button class="key">8</button><button class="key">9</button>
          <button class="key wide" data-act="clr">CLR</button><button class="key">0</button>
          <button class="key wide" data-act="bksp">⌫</button><button class="key success wide" data-act="ok">OK</button>
          <button class="key danger wide" data-act="cancel">Cancel</button>
        </div>
      </div>
    </div>

    <!-- toast -->
    <div id="gmToast" aria-live="polite"></div>

    <script>
      // GM Dock script - complet & robuste
      (function(){
        const getVM = () => window.II_DEBUG?.getTracker?.() || null;
        const koUnwrap = v => (typeof v === "function" ? v() : v);

        function waitFor(fn, timeout=2200){
          const t0 = performance.now();
          return new Promise(resolve=>{
            (function loop(){
              const v = fn();
              if (v) return resolve(v);
              if (performance.now() - t0 > timeout) return resolve(null);
              requestAnimationFrame(loop);
            })();
          });
        }
        function setNativeValue(el, value){
          const d = Object.getOwnPropertyDescriptor(el.__proto__, 'value') ||
                    Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
          d.set.call(el, value);
          el.dispatchEvent(new Event('input',  { bubbles:true }));
          el.dispatchEvent(new Event('change', { bubbles:true }));
        }
        const isVisible = el => !!el && el.offsetParent !== null && getComputedStyle(el).visibility !== 'hidden';

        // toast
        function toast(msg, kind="ok", t=1500){
          const el = document.getElementById("gmToast");
          if(!el) return;
          el.className = "";
          el.textContent = msg;
          el.classList.add(kind, "show");
          clearTimeout(el._t);
          el._t = setTimeout(()=> el.classList.remove("show"), t);
        }

        // find damage modal - tolerant: take last visible numeric/text input
        function findDamagePrompt(){
          const inputs = [...document.querySelectorAll('input[type="number"], input[type="text"]')].filter(isVisible);
          if (!inputs.length) return null;
          const input = inputs[inputs.length - 1];
          const box   = input.closest('form, [role="dialog"], .modal, .ReactModal__Content') || input.parentElement || document.body;
          let okBtn = (box && [...box.querySelectorAll('button,[role="button"]')].reverse().find(b=>{
            const t = (b.textContent || '').toLowerCase().trim();
            const aria = (b.ariaLabel || '').toLowerCase();
            const html = (b.innerHTML || '').toLowerCase();
            return t === '✓' || t === 'ok' || /apply|confirm|valider|confirmer/.test(t) || /check/.test(aria) || /check|✓/.test(html);
          })) || null;
          if (!okBtn){
            let sib = input.nextElementSibling;
            while (sib && sib.tagName !== 'BUTTON' && !sib.matches('[role="button"]')) sib = sib.nextElementSibling;
            if (sib) okBtn = sib;
          }
          return { root: box, form: input.closest('form'), input, okBtn };
        }

        // encounter helpers
        function getEncounter(vm){
          return vm?.Encounter || vm?.EncounterCommander?.Encounter || vm?.GetEncounter?.() || null;
        }
        function getActiveId(enc){
          return koUnwrap(enc?.ActiveCombatantId) ||
                 enc?.lastVisibleActiveCombatantId ||
                 koUnwrap(enc?.EncounterFlow?.ActiveCombatantId) || null;
        }
        async function getActiveVM(vm){
          const enc = getEncounter(vm); if (!enc) return null;
          const cc  = vm.CombatantCommander; if (!cc) return null;

          // 1) already selected
          let selected = koUnwrap(cc.SelectedCombatants);
          if (Array.isArray(selected) && selected[0] && typeof selected[0].Name === "function") return selected[0];

          // 2) try select current
          if (typeof cc.selectByOffset === "function") {
            try { cc.selectByOffset(0); } catch(e){}
            selected = koUnwrap(cc.SelectedCombatants);
            if (Array.isArray(selected) && selected[0] && typeof selected[0].Name === "function") return selected[0];
          }

          // 3) combatant details map
          const id = getActiveId(enc);
          let dict = koUnwrap(cc.CombatantDetails);
          if (dict && typeof dict === "object") {
            const vals = Array.isArray(dict) ? dict : Object.values(dict);
            for (const vmItem of vals) {
              const vmId = koUnwrap(vmItem?.Id) ?? koUnwrap(vmItem?.Combatant?.Id);
              if (vmId === id && typeof vmItem?.Name === "function") return vmItem;
            }
          }

          // 4) fall back to scanning list
          const listKO = koUnwrap(enc?.Combatants) ?? koUnwrap(enc?.combatants);
          const list = Array.isArray(listKO) ? listKO : (listKO && typeof listKO === "object" ? Object.values(listKO) : []);
          for (const vmItem of list) {
            if (typeof vmItem?.Name === "function" && (koUnwrap(vmItem?.IsActive) === true)) return vmItem;
            const vmId = koUnwrap(vmItem?.Id) ?? koUnwrap(vmItem?.Combatant?.Id);
            if (vmId === id && typeof vmItem?.Name === "function") return vmItem;
          }
          return null;
        }

        function getPlayerVMs(vm){
          const list = typeof vm?.CombatantViewModels === "function"
            ? vm.CombatantViewModels()
            : vm?.CombatantViewModels || [];

          return (Array.isArray(list) ? list : []).filter(c => {
            const combatant = koUnwrap(c?.Combatant);
            const isPC = combatant?.IsPlayerCharacter;
            return typeof isPC === "function" ? !!isPC() : !!isPC;
          });
        }

        // apply HP delta - open modal once, wait, fill, submit robustly
async function hpDelta(delta){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const cc = vm.CombatantCommander;
          if (!cc || typeof cc.applyDamageForCombatants !== "function") { toast("API indisponible", "dmg", 1200); return; }

          const activeVM = await getActiveVM(vm);
          if (!activeVM) { toast("Aucun combattant actif", "dmg", 1200); return; }

          try { cc.latestRoll = null; } catch(e){}
          const valStr = String(Math.trunc(delta));

          // open once
          cc.applyDamageForCombatants([activeVM]);

          // wait for prompt (tolerant)
          const prompt = await waitFor(findDamagePrompt, 2200);
          if (!prompt || !prompt.input) { toast("Prompt non détecté.", "dmg", 1200); return; }

          // write (triple write)
          prompt.input.focus();
          setNativeValue(prompt.input, valStr);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 40);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 120);

          // submit robust
          const submitPrompt = ()=>{
            if (prompt.okBtn) {
              try { prompt.okBtn.click(); return true; } catch(e){}
            }
            if (prompt.form && typeof prompt.form.requestSubmit === 'function') {
              try { prompt.form.requestSubmit(); return true; } catch(e){}
            }
            if (prompt.form) {
              try {
                const ok = prompt.form.dispatchEvent(new Event('submit', { bubbles:true, cancelable:true }));
                if (ok) return true;
              } catch(e){}
            }
            try {
              const kd = new KeyboardEvent('keydown', { key:'Enter', code:'Enter', bubbles:true, cancelable:true });
              Object.defineProperty(kd,'keyCode',{get:()=>13}); Object.defineProperty(kd,'which',{get:()=>13});
              prompt.input.dispatchEvent(kd);
              const ku = new KeyboardEvent('keyup',   { key:'Enter', code:'Enter', bubbles:true, cancelable:true });
              Object.defineProperty(ku,'keyCode',{get:()=>13}); Object.defineProperty(ku,'which',{get:()=>13});
              prompt.input.dispatchEvent(ku);
            } catch(e){}
            return false;
          };

          setTimeout(()=>{ submitPrompt(); }, 180);
          setTimeout(()=>{ try { cc.latestRoll = null; } catch(e){} }, 260);

          // local feedback
          const pretty = valStr.startsWith('-') ? `Heal ${Math.abs(parseInt(valStr))}` : `DMG ${valStr}`;
          toast(pretty, valStr.startsWith('-') ? "heal" : "dmg", 1200);
          try { navigator.vibrate?.(18); } catch(e){}
        }

        async function hpDeltaPlayers(delta){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const cc = vm.CombatantCommander;
          if (!cc || typeof cc.applyDamageForCombatants !== "function") { toast("API indisponible", "dmg", 1200); return; }

          const players = getPlayerVMs(vm);
          if (!players.length) { toast("Aucun PJ", "dmg", 1200); return; }

          try { cc.latestRoll = null; } catch(e){}
          const valStr = String(Math.trunc(delta));
          cc.applyDamageForCombatants(players);

          const prompt = await waitFor(findDamagePrompt, 2200);
          if (!prompt || !prompt.input) { toast("Prompt non d�tect�.", "dmg", 1200); return; }

          prompt.input.focus();
          setNativeValue(prompt.input, valStr);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 40);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 120);

          const submitPrompt = ()=>{
            if (prompt.okBtn) {
              try { prompt.okBtn.click(); return true; } catch(e){}
            }
            if (prompt.form && typeof prompt.form.requestSubmit === 'function') {
              try { prompt.form.requestSubmit(); return true; } catch(e){}
            }
            if (prompt.form) {
              try {
                const ok = prompt.form.dispatchEvent(new Event('submit', { bubbles:true, cancelable:true }));
                if (ok) return true;
              } catch(e){}
            }
            return false;
          };

          setTimeout(()=>{ submitPrompt(); }, 180);
          setTimeout(()=>{ try { cc.latestRoll = null; } catch(e){} }, 260);

          const pretty = valStr.startsWith('-') ? `Heal ${Math.abs(parseInt(valStr))}` : `DMG ${valStr}`;
          toast(pretty, valStr.startsWith('-') ? "heal" : "dmg", 1200);
          try { navigator.vibrate?.(18); } catch(e){}
        }

        async function hpDeltaSelection(delta){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const cc = vm.CombatantCommander;
          if (!cc || typeof cc.applyDamageForCombatants !== "function") { toast("API indisponible", "dmg", 1200); return; }

          const selected = (koUnwrap(cc.SelectedCombatants) || []).filter(c => typeof c?.Name === "function");
          if (!selected.length) { toast("Sélection vide", "dmg", 1200); return; }

          try { cc.latestRoll = null; } catch(e){}
          const valStr = String(Math.trunc(delta));
          cc.applyDamageForCombatants(selected);

          const prompt = await waitFor(findDamagePrompt, 2200);
          if (!prompt || !prompt.input) { toast("Prompt non détecté.", "dmg", 1200); return; }

          prompt.input.focus();
          setNativeValue(prompt.input, valStr);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 40);
          setTimeout(()=>{ try { setNativeValue(prompt.input, valStr); } catch(e){} }, 120);

          const submitPrompt = ()=>{
            if (prompt.okBtn) {
              try { prompt.okBtn.click(); return true; } catch(e){}
            }
            if (prompt.form && typeof prompt.form.requestSubmit === 'function') {
              try { prompt.form.requestSubmit(); return true; } catch(e){}
            }
            if (prompt.form) {
              try {
                const ok = prompt.form.dispatchEvent(new Event('submit', { bubbles:true, cancelable:true }));
                if (ok) return true;
              } catch(e){}
            }
            return false;
          };

          setTimeout(()=>{ submitPrompt(); }, 180);
          setTimeout(()=>{ try { cc.latestRoll = null; } catch(e){} }, 260);

          const pretty = valStr.startsWith('-') ? `Heal ${Math.abs(parseInt(valStr))}` : `DMG ${valStr}`;
          toast(pretty, valStr.startsWith('-') ? "heal" : "dmg", 1200);
          try { navigator.vibrate?.(18); } catch(e){}
        }

        function selectAllCombatants(){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const list = typeof vm.CombatantViewModels === "function" ? vm.CombatantViewModels() : (vm.CombatantViewModels || []);
          if (Array.isArray(list) && vm.CombatantCommander?.SelectMany) {
            vm.CombatantCommander.SelectMany(list);
            toast(`Select all (${list.length})`, "heal", 800);
          }
        }

        function clearSelection(){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          if (vm.CombatantCommander?.Deselect) {
            vm.CombatantCommander.Deselect();
            toast("Sélection vidée", "dmg", 800);
          }
        }

        // next turn
        function doNext(){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const ec = vm.EncounterCommander || vm.Encounter || vm.TurnCommander;
          const f = ec?.NextTurn || ec?.AdvanceTurn || ec?.Next || ec?.GoToNext || ec?.AdvanceRound || ec?.NextCombatant;
          if (typeof f === "function") { try { f.call(ec); } catch(e){ console.warn(e); } }
        }
        function doPrev(){
          const vm = getVM(); if (!vm) { toast("II_DEBUG absent", "dmg", 1200); return; }
          const ec = vm.EncounterCommander || vm.Encounter || vm.TurnCommander;
          const f = ec?.PreviousTurn || ec?.Previous || ec?.Prev || ec?.GoToPrevious || ec?.PrevCombatant || ec?.Rewind;
          if (typeof f === "function") { try { f.call(ec); } catch(e){ console.warn(e); } }
        }

        // numpad UI
        const pad = document.getElementById("numPad");
        const padTitle = document.getElementById("padTitle");
        const padDisplay = document.getElementById("padDisplay");
        const padTargets = document.getElementById("padTargets");
        const padTargetList = padTargets?.querySelector(".target-list");
        let mode = "dmg";
        let target = "active"; // active | group | players
        let buffer = "";
        let targetItems = [];
        const MODS = {
          full: 1,
          half: 0.5,
          quarter: 0.25,
          none: 0
        };

        function mapVM(vm){
          const id = koUnwrap(vm?.Combatant?.Id) || koUnwrap(vm?.Id);
          const name = (typeof vm?.Name === "function" ? vm.Name() : vm?.Name) || "Unknown";
          return { id, name, vm, mod: "full" };
        }

        function renderTargets(list){
          if(!padTargets || !padTargetList) return;
          padTargetList.innerHTML = "";
          padTargets.classList.toggle("empty", list.length===0);
          if(!list.length) return;
          list.forEach((item, idx)=>{
            const row = document.createElement("div");
            row.className = "target-row";
            row.dataset.id = item.id;
            const name = document.createElement("div");
            name.className = "target-name";
            name.textContent = item.name;
            const select = document.createElement("select");
            select.className = "target-mod";
            select.dataset.id = item.id;
            ["full","half","quarter","none"].forEach(v=>{
              const opt = document.createElement("option");
              opt.value = v;
              opt.textContent = v==="full" ? "100%" : v==="half" ? "50%" : v==="quarter" ? "25%" : "0%";
              if(item.mod===v) opt.selected = true;
              select.appendChild(opt);
            });
            select.addEventListener("change",(e)=>{
              const val = e.target.value;
              const idx = targetItems.findIndex(t=>t.id===item.id);
              if(idx>=0) targetItems[idx].mod = val;
            });
            row.appendChild(name);
            row.appendChild(select);
            padTargetList.appendChild(row);
          });
        }

        function buildTargetList(t){
          const vm = getVM();
          if(!vm) return [];
          if(t==="players") return getPlayerVMs(vm).map(mapVM);
          if(t==="group"){
            const cc = vm.CombatantCommander;
            const selected = (koUnwrap(cc?.SelectedCombatants) || []).filter(c => typeof c?.Name === "function");
            return selected.map(mapVM);
          }
          if(t==="active"){
            const active = koUnwrap(vm?.CombatantCommander?.SelectedCombatants)?.[0] || null;
            const fallback = getActiveVM(vm);
            const pick = active || fallback;
            return pick ? [mapVM(pick)] : [];
          }
          return [];
        }

        function openPad(m, t="active"){
          mode = m; target = t; buffer = "";
          try { const vm = getVM(); vm?.CombatantCommander && (vm.CombatantCommander.latestRoll = null); } catch(e){}
          padTitle.textContent = (m === "heal") ? "HEAL - amount" : "DMG - amount";
          padDisplay.textContent = "0";
          targetItems = buildTargetList(t);
          renderTargets(targetItems);
          pad.style.display = "flex";
          pad.setAttribute("aria-hidden","false");
        }
        function closePad(){ pad.style.display = "none"; pad.setAttribute("aria-hidden","true"); }

        function computeDelta(base, modKey){
          const mult = MODS[modKey] ?? 1;
          const val = base * mult;
          return Math[base>0 ? "round" : "round"](val);
        }

        function applyToTarget(item, delta){
          if(!item?.vm) return;
          try{
            if(typeof item.vm.ApplyDamage === "function"){
              item.vm.ApplyDamage(String(delta));
            }
          }catch(e){ console.warn(e); }
        }

        function commitPad(){
          const n = parseInt(buffer||"0",10);
          if (!Number.isFinite(n) || n<=0){ closePad(); return; }
          const delta = (mode === "heal") ? -n : n;
          closePad();
          // immediate feedback
          toast((mode==="heal" ? `+${n} HP` : `-${n} HP`), mode==="heal" ? "heal" : "dmg");
          try { navigator.vibrate?.(20); } catch(e){}
          const hasTargets = targetItems.length>0 && (target==="group" || target==="players");
          if(hasTargets){
            const vm = getVM();
            const logs = [];
            targetItems.forEach(it=>{
              const modDelta = computeDelta(delta, it.mod);
              logs.push(`${it.name} ${modDelta>0?`-${modDelta}`:`+${Math.abs(modDelta)}`}`);
              applyToTarget(it, modDelta);
            });
            if(vm?.EventLog?.AddEvent){
              vm.EventLog.AddEvent(`${mode==="heal"?"Heal":"Damage"}: ${logs.join(", ")}`);
            }
          } else if (target === "group") {
            hpDeltaSelection(delta);
          } else if (target === "players") {
            hpDeltaPlayers(delta);
          } else {
            hpDelta(delta);
          }
        }

        pad.addEventListener("click",(e)=>{
          const k=e.target.closest(".key"); if(!k) return;
          const act=k.dataset.act;
          if(!act){
            const d=k.textContent.trim();
            if(buffer.length<5){ buffer=(buffer==="0"?d:buffer+d); }
            padDisplay.textContent=buffer||"0"; return;
          }
          if(act==="bksp"){ buffer=buffer.slice(0,-1); padDisplay.textContent=buffer||"0"; return; }
          if(act==="clr"){ buffer=""; padDisplay.textContent="0"; return; }
          if(act==="ok"){ commitPad(); return; }
          if(act==="cancel"){ closePad(); return; }
        });
        pad.addEventListener("click",(e)=>{ if(e.target===pad) closePad(); });
        window.addEventListener("keydown",(e)=>{
          if(pad.style.display!=="flex") return;
          if(e.key==="Escape"){ closePad(); return; }
          const isDigit = /^[0-9]$/.test(e.key);
          if(isDigit){
            e.preventDefault();
            if(buffer.length<6){
              buffer = buffer==="0" ? e.key : buffer + e.key;
              padDisplay.textContent = buffer||"0";
            }
          } else if(e.key==="Backspace"){
            e.preventDefault();
            buffer = buffer.slice(0,-1);
            padDisplay.textContent = buffer||"0";
          } else if(e.key==="Enter"){
            e.preventDefault();
            commitPad();
          }
        });

// dock + buttons wiring + pulse + flip
        const dock = document.getElementById("gmDock");
        const dockHandle = document.getElementById("dockHandle");
        const sectionToggles = [...document.querySelectorAll("[data-section-toggle]")];
        const DOCK_SECTION_KEY = "__iiDockSections";
        const DOCK_POS_KEY = "__iiDockPos";
        const DOCK_SIDE_KEY = "__iiDockLeft";
        const DOCK_COMPACT_KEY = "__iiDockCompact";
        function setSectionState(id, collapsed){
          const state = JSON.parse(localStorage.getItem(DOCK_SECTION_KEY) || "{}");
          state[id] = collapsed ? 1 : 0;
          localStorage.setItem(DOCK_SECTION_KEY, JSON.stringify(state));
        }
        function applySectionState(){
          const state = JSON.parse(localStorage.getItem(DOCK_SECTION_KEY) || "{}");
          sectionToggles.forEach(btn=>{
            const id = btn.dataset.sectionToggle;
            const sec = btn.closest(".section");
            const collapsed = state[id] === 1;
            sec?.classList.toggle("collapsed", collapsed);
          });
        }
        function readDockPos(){
          try {
            const raw = localStorage.getItem(DOCK_POS_KEY);
            if(!raw) return null;
            const obj = JSON.parse(raw);
            if (obj && typeof obj.x === "number" && typeof obj.y === "number") return obj;
          } catch(e){}
          return null;
        }
        function clampDockPos(x,y){
          const rect = dock.getBoundingClientRect();
          const margin = 8;
          const maxX = Math.max(margin, window.innerWidth - rect.width - margin);
          const maxY = Math.max(margin, window.innerHeight - rect.height - margin);
          return { x: Math.min(Math.max(margin,x), maxX), y: Math.min(Math.max(margin,y), maxY) };
        }
        function setDockPos(pos){
          const clamped = clampDockPos(pos.x, pos.y);
          dock.style.left = `${clamped.x}px`;
          dock.style.top = `${clamped.y}px`;
          dock.style.right = "auto";
          dock.style.bottom = "auto";
          localStorage.setItem(DOCK_POS_KEY, JSON.stringify(clamped));
          return clamped;
        }
        function snapDock(side){
          const margin = 12;
          const rect = dock.getBoundingClientRect();
          const savedY = readDockPos()?.y;
          const y = Number.isFinite(savedY) ? savedY : window.innerHeight - rect.height - margin;
          const placed = setDockPos({
            x: side === "left" ? margin : Math.max(margin, window.innerWidth - rect.width - margin),
            y
          });
          dock.classList.toggle("left", side === "left");
          localStorage.setItem(DOCK_SIDE_KEY, side === "left" ? "1" : "0");
          return placed;
        }
        function initDockPosition(){
          const saved = readDockPos();
          const side = localStorage.getItem(DOCK_SIDE_KEY) === "1" ? "left" : "right";
          requestAnimationFrame(()=>{
            if (saved) {
              setDockPos(saved);
              dock.classList.toggle("left", saved.x < window.innerWidth / 2);
            } else {
              snapDock(side);
            }
          });
        }
        function enableDockDrag(){
          if(!dockHandle || !dock) return;
          let pointerId = null;
          let start = { x:0, y:0 };
          const move = (e)=>{
            if(pointerId!==e.pointerId) return;
            const pos = setDockPos({ x: e.clientX - start.x, y: e.clientY - start.y });
            dock.classList.toggle("left", pos.x < window.innerWidth / 2);
          };
          const end = (e)=>{
            if(pointerId===null || (e && e.pointerId!==pointerId)) return;
            dock.classList.remove("dragging");
            dockHandle.releasePointerCapture?.(pointerId);
            pointerId = null;
            window.removeEventListener("pointermove", move);
            window.removeEventListener("pointerup", end);
            window.removeEventListener("pointercancel", end);
          };
          dockHandle.addEventListener("pointerdown",(e)=>{
            pointerId = e.pointerId;
            const rect = dock.getBoundingClientRect();
            start = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            dock.classList.add("dragging");
            dockHandle.setPointerCapture?.(pointerId);
            window.addEventListener("pointermove", move);
            window.addEventListener("pointerup", end);
            window.addEventListener("pointercancel", end);
          });
        }
        function setCompactMode(on){
          dock.classList.toggle("compact", !!on);
          localStorage.setItem(DOCK_COMPACT_KEY, on ? "1" : "0");
        }

        const btnDmg  = document.getElementById("btnDmg");
        const btnHeal = document.getElementById("btnHeal");
        const btnPrev = document.getElementById("btnPrev");
        const btnNext = document.getElementById("btnNext");
        const btnFlip = document.getElementById("btnFlip");
        const btnCompact = document.getElementById("btnCompact");
        const btnSelectAll = document.getElementById("btnSelectAll");
        const btnClearSel  = document.getElementById("btnClearSel");
        const btnPlayersDmg  = document.getElementById("btnPlayersDmg");
        const btnPlayersHeal = document.getElementById("btnPlayersHeal");
        const btnGroupDmg  = document.getElementById("btnGroupDmg");
        const btnGroupHeal = document.getElementById("btnGroupHeal");
        function pulse(btn){ btn.classList.add("pulse"); setTimeout(()=>btn.classList.remove("pulse"), 200); }
        function setBadge(btn, count){ if(!btn) return; btn.dataset.badge = count > 0 ? String(count) : ""; }
        function updateContextualState(){
          const vm = getVM();
          const cc = vm?.CombatantCommander;
          const enc = getEncounter(vm);
          const selected = (koUnwrap(cc?.SelectedCombatants) || []).filter(c => typeof c?.Name === "function");
          const selectedCount = selected.length;
          const players = getPlayerVMs(vm);
          const playerCount = players.length;
          const hasActive = !!getActiveVM(vm);

          btnGroupDmg.disabled = selectedCount === 0;
          btnGroupHeal.disabled = selectedCount === 0;
          btnPlayersDmg.disabled = playerCount === 0;
          btnPlayersHeal.disabled = playerCount === 0;
          btnPrev.disabled = !hasActive;

          setBadge(btnGroupDmg, selectedCount);
          setBadge(btnGroupHeal, selectedCount);
          setBadge(btnPlayersDmg, playerCount);
          setBadge(btnPlayersHeal, playerCount);

          if(enc){
            const round = koUnwrap(enc.EncounterFlow?.Round) || null;
            dock.dataset.round = round ? `R${round}` : "";
          }
        }

        btnDmg.addEventListener("click", (e)=>{ pulse(e.currentTarget); openPad("dmg","active"); });
        btnHeal.addEventListener("click",(e)=>{ pulse(e.currentTarget); openPad("heal","active"); });
        btnPrev.addEventListener("click",(e)=>{ pulse(e.currentTarget); doPrev(); });
        btnNext.addEventListener("click",(e)=>{ pulse(e.currentTarget); doNext(); });
        btnSelectAll.addEventListener("click",(e)=>{ pulse(e.currentTarget); selectAllCombatants(); });
        btnClearSel.addEventListener("click",(e)=>{ pulse(e.currentTarget); clearSelection(); });
        btnPlayersDmg.addEventListener("click",(e)=>{ pulse(e.currentTarget); openPad("dmg","players"); });
        btnPlayersHeal.addEventListener("click",(e)=>{ pulse(e.currentTarget); openPad("heal","players"); });
        btnGroupDmg.addEventListener("click",(e)=>{ pulse(e.currentTarget); openPad("dmg","group"); });
        btnGroupHeal.addEventListener("click",(e)=>{ pulse(e.currentTarget); openPad("heal","group"); });
        btnFlip.addEventListener("click",(e)=>{
          const toSide = dock.classList.contains("left") ? "right" : "left";
          snapDock(toSide);
        });
        btnCompact.addEventListener("click",(e)=>{
          const on = !dock.classList.contains("compact");
          setCompactMode(on);
          pulse(e.currentTarget);
        });
        sectionToggles.forEach(btn=>{
          btn.addEventListener("click",()=>{
            const id = btn.dataset.sectionToggle;
            const sec = btn.closest(".section");
            const collapsed = !sec.classList.contains("collapsed");
            sec.classList.toggle("collapsed", collapsed);
            setSectionState(id, collapsed);
          });
        });

        initDockPosition();
        enableDockDrag();
        applySectionState();
        setCompactMode(localStorage.getItem(DOCK_COMPACT_KEY)==="1");
        window.addEventListener("resize", ()=>{ const saved = readDockPos(); if(saved) setDockPos(saved); });
        setInterval(updateContextualState, 800);

        // ready indicator
        const readyCheck=setInterval(()=>{
          const ok=!!(window.II_DEBUG&&window.II_DEBUG.getTracker);
          dock.style.opacity=ok?"":"0.5"; if(ok) clearInterval(readyCheck);
        },300);

      })();
    </script>
  </body>
</html>

